/*
 * CSGME Data logger 11 SEP 2020
 * Airflow sensor - SD8000
 * https://www.ifm.com/mounting/80004729UK.pdf
 * 
 * Air pressure - PT5404
 * https://www.ifm.com/mounting/80280889UK.pdf   *   
 */
#include <SPI.h>
#include <Indio.h>
#include <Wire.h>
#include <UC1701.h>
#include <MCP7940.h>
#include <SD.h>

#define airflowPin 1
#define airpresPin 2
#define chipSelect 4 //SD Card
#define downButton 23
#define enterButton 24
#define upButton 25
#define backLight 26

#define lightTime 5000
#define displayPeriod 250 //display update frequency
#define dataPeriod 30000 //duty cycle calc frequency
#define airflowMax 225 //max value for SD8000
#define airpresMax 140 //max value PT5404

File dataFile;
byte standbyRate = 20; //threshold for PUMP ON state
byte impulseValue = 1; //totaliser pulse from SD8000 
byte standbyMin = 20; //min acceptable threshold for pump on
byte standbyMax = 100; //max value for threshold
int airPres = 0; //air pressure PSI
int airFlow = 0; //airflow Nm3/h
int maxFlow = 0; //maximum airflow while pump on
int minFlow = 0;  //minimum airflow while pump off
int upPercent = 0; //duty cycle of pump
unsigned long displayTime = 0; //time since display was updated
unsigned long dataTime = 0; //time since duty cycle was calculated

unsigned long lastAction = 0;//keeps track of last button activity

float upTime = 0; // multiply by dataTime for total pump on time
float downTime = 0; // pump off time
volatile int totalAir; // total air usage in m3. Read from SD on startup so 
                       // must be cleared between trials
                       
boolean sdError = false; // Flag for error writing to SD Card
boolean pumpState = false; //Pump on/off
volatile boolean changeStandby = false; //Flag for threshold menu

static UC1701 lcd;
static const byte LCD_WIDTH = 128;
static const byte LCD_HEIGHT = 64;
static const byte logo[] = {
0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0x7C,0x3E,0x1E,0x0E,0x0E,0x0E,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x1E,0x1E,
0x3C,0x7C,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,
0xE0,0xF0,0xF8,0x7E,0x3F,0x1F,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x1E,0x3F,0x7E,0x7C,0xF8,0xF0,0xE0,0xC0,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0x78,0x3C,0x1E,0x0E,
0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,
0x1F,0x3F,0x7E,0x7C,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,
0xFF,0xFE,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0xFE,0xFE,0xFE,0xFC,0xE0,0xE0,0xE0,
0xE0,0xE0,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
0x03,0x01,0x00,0x00,0x00,0x00,0x00,0xFC,0xFE,0xFE,0xFE,0x0E,0x0E,0x0E,0x0E,0x0E,
0x0E,0x0E,0x3E,0x3E,0x3E,0x3C,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x3F,0x3F,0x3F,
0x1F,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,
0xFC,0xFE,0xFF,0xFE,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x7E,0x7F,0x7E,0x7C,
0x70,0x70,0x70,0x70,0x71,0x73,0x7F,0x7F,0x7F,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x0F,0x1F,0x3F,0x7F,
0xFC,0xF8,0xF0,0xE0,0x80,0x80,0x80,0x83,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,
0x87,0x87,0x87,0x87,0x87,0x07,0x07,0x07,0x0F,0x0F,0x1F,0x3F,0x7E,0xFC,0xF0,0xE0,
0xE0,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0xFC,0xFC,0x3C,0x3C,0x3C,
0x3C,0x3C,0x3C,0x3C,0x3C,0xFC,0xFC,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFC,0xFC,0xFC,0x3C,0x3C,0x3C,
0x3C,0x3C,0x3C,0xFC,0xFC,0xFC,0xFC,0xFC,0x00,0x00,0x00,0x00,0xE0,0xE0,0xE0,0xE0,
0xE0,0xE1,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0xE3,0x03,0x03,0x03,0x03,0x03,
0x03,0x03,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,
0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x1F,0x0F,0x1F,0xFF,0xFE,0xFE,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x1F,0x3F,0x3F,0x7F,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x02,0x07,
0x07,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x07,0x00,0x80,0x80,
0xC0,0xF0,0xF8,0xFF,0x7F,0x3F,0x1F,0x0F,0x00,0x00,0x00,0x00,0x0F,0x1F,0x3F,0x7F,
0xFC,0xF8,0xF0,0xC0,0x80,0x80,0x00,0x07,0x0F,0x1F,0x1F,0x1E,0x1E,0x1E,0x1E,0x1E,
0x1E,0x1E,0x1F,0x1F,0x0F,0x07,0x00,0x00,0x80,0xC0,0xF0,0xF8,0xF8,0x7F,0x7F,0x3F,
0x1F,0x00,0x00,0x00,0x00,0x00,0x1F,0x3F,0x7F,0xFF,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
0x01,0x07,0x07,0x0F,0x0F,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0F,0x0F,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x0F,0x0F,0x0F,0x0F,0x0F,
0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x07,
0x07,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x03,0x07,0x07,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0E,0x0F,0x0F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,0x0F,0x0F,0x0F,
0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,
0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

const byte CMD_WREN = 0x06; //0000 0110 Set Write Enable Latch
const byte CMD_WRDI = 0x04; //0000 0100 Write Disable
const byte CMD_RDSR = 0x05; //0000 0101 Read Status Register
const byte CMD_WRSR = 0x01; //0000 0001 Write Status Register
const byte CMD_READ = 0x03; //0000 0011 Read Memory Data
const byte CMD_WRITE = 0x02; //0000 0010 Write Memory Data
const int FRAM_CS1 = 6; //chip select 1

/*
 * Write to FRAM on ethernet expansion module
 * FRAM is used to store threshold ON/OFF value if power is lost
 */
int FRAMWrite(int addr, byte *buf, int count=1){
  if (addr > 0x7ff) return -1;

  byte addrMSB = (addr >> 8) & 0xff;
  byte addrLSB = addr & 0xff;

  digitalWrite(FRAM_CS1, LOW);   
  SPI.transfer(CMD_WREN);  //write enable 
  digitalWrite(FRAM_CS1, HIGH);

  digitalWrite(FRAM_CS1, LOW);
  SPI.transfer(CMD_WRITE); //write command
  SPI.transfer(addrMSB);
  SPI.transfer(addrLSB);

  for (int i = 0;i < count;i++) SPI.transfer(buf[i]);

  digitalWrite(FRAM_CS1, HIGH);

  return 0;
}

/*
 * Read from FRAM on ethernet expansion module
 */
int FRAMRead(int addr, byte *buf, int count=1){
  if (addr > 0x7ff) return -1;

  byte addrMSB = (addr >> 8) & 0xff;
  byte addrLSB = addr & 0xff;

  digitalWrite(FRAM_CS1, LOW);

  SPI.transfer(CMD_READ);
  SPI.transfer(addrMSB);
  SPI.transfer(addrLSB);

  for (int i=0; i < count; i++) buf[i] = SPI.transfer(0x00);

  digitalWrite(FRAM_CS1, HIGH);

  return 0;
}

void setup(){
  pinMode(10, OUTPUT); // FRAM lines
  pinMode(4, OUTPUT); 
  digitalWrite(10, HIGH);
  digitalWrite(4, HIGH);
  
  SerialUSB.begin(9600);
  Wire.begin();  

  pinMode(FRAM_CS1, OUTPUT);
  digitalWrite(FRAM_CS1, HIGH);

  Indio.setADCResolution(18);
  Indio.analogReadMode(airflowPin, mA);
  Indio.analogReadMode(airpresPin, mA);
  
  pinMode(upButton, INPUT);
  pinMode(downButton, INPUT);
  pinMode(enterButton, INPUT);
  pinMode(backLight, OUTPUT);
  
  pinMode(chipSelect, OUTPUT);
  digitalWrite(chipSelect,HIGH);
  
  Indio.digitalMode(airflowPin, OUTPUT); //clear channel
  Indio.digitalWrite(airflowPin, LOW);
  Indio.digitalMode(airflowPin, INPUT);

  SPI.begin();
  SPI.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
  
  attachInterrupt(8,totaliser, FALLING);    //D1 to OU1 on SD8000. 1 pulse for 1 Nm3 of air consumed
  attachInterrupt(24, enter, FALLING);      // D24 is the Enter button (pull-up)
  attachInterrupt(25, up, FALLING);         // D25 is the Up button (pull-up)
  attachInterrupt(23, down, FALLING);       // D23 is the Down button (pull-up)
  
  // true for MCP7940N vith back-up battery
  // false for MCP7940M or MCP7940N vith VBAT connected to ground
  RTCind.start(true);
  lcd.begin();
  lcd.clear();
  lcd.home();
  lcd.drawBitmap(logo, LCD_WIDTH, LCD_HEIGHT);
  delay(1000);
  initDisplay();
  lcd.setCursor(0,7);
  if(!SD.begin(chipSelect)){
    lcd.print("SD Failure");
    sdError = 1;
   }
  else{
    lcd.print("SD OK");
    lcd.setCursor(0,7);
    lcd.print("     ");
  }
  delay(1000);

  //Dump SD card data through SerialUSB & load last total air recorded.
  //a backup total also exists on the SD8000
  if(SD.exists("data.txt")){
    dataFile = SD.open("data.txt",FILE_READ);
    while(dataFile.peek()>= 0){
      SerialUSB.print(char(dataFile.read()));
    }
    SerialUSB.println();
    
    String inString;
    String outString;
    int filePosition = dataFile.size();
    int counter = 0;
        dataFile.seek(dataFile.size()-1);
    while(dataFile.peek() != 'T' && counter < 10){
      filePosition--;
      dataFile.seek(filePosition);
      counter++;
      }
    if(counter < 10){
      filePosition += 2;
      dataFile.seek(filePosition);
      while(dataFile.peek()>= 0){
        inString.concat(char(dataFile.read()));
      }
    totalAir = inString.toInt();
    }
  dataFile.close();
  }
  else{
    lcd.setCursor(0,7);
    lcd.print("DATA.TXT NOT FOUND");
    delay(2000);
    lcd.print("                  ");
  }  
  
  //Load threshold value from FRAM
  SPI.begin(); 
  SPI.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
  byte buf[1];
  FRAMRead(1, (byte*) buf);
  standbyRate = int(buf[0]);
  standbyRate = constrain(standbyRate, standbyMin, standbyMax);
  changeStandby = false;
}

void loop(){
  if(SerialUSB.available()){
    parseUSB();
  }
  
  if((millis() - displayTime) > displayPeriod){
    parseData();    
    updateDisplay();
    displayTime = millis();
    if(pumpState){
      maxFlow = max(maxFlow,airFlow);
    }
    else{
      minFlow = min(minFlow,airFlow);
    }
  }
  
  if(airFlow > standbyRate && !pumpState){
    pumpState = true;
    logEvent();
    maxFlow = 0;
  }
  if(airFlow < standbyRate && pumpState){
    pumpState = false;
    logEvent();
    minFlow = 0;
  }

  if((millis() - dataTime) > dataPeriod){
    if(pumpState){
      upTime++;
    }
    else{
      downTime++;
    }
    upPercent = int(100*(upTime/(upTime + downTime)));
    dataTime = millis();
  }

  if((millis()-lastAction) > lightTime){
    digitalWrite(backLight,LOW);
  }
}

/*
 * Reads and scales 4-20mA signal from sensors for pres and flow
 * Reading of < 350mA flags a comm error. 350 < x < 400 mA is scaled up to 400mA
 */
void parseData(){
  float flow = Indio.analogRead(airflowPin);
  float pres = Indio.analogRead(airpresPin);
  flow *= 100;
  pres *= 100;
  int flowInt = int(flow);
  int presInt = int(pres);
  
  if(presInt < 350){
    presInt = -1;
  }
  else if(presInt < 400){
    presInt = 400;  
  }
  
  if(flowInt < 350){
    flowInt = -1;
  }
  else if(flowInt < 400){
    flowInt = 400;
  }
  
  airFlow = map(flowInt,400,2000,0,airflowMax);
  airPres = map(presInt,400,2000,0,airpresMax);
}

/*
 * Updates values on home screenm if changeStanby is FALSE
 * Otherwise it shows threshold value & writes new value to FRAM
 */
void updateDisplay(){
  if(!changeStandby){
    lcd.setCursor(0,1);
    lcd.print(timeString());
    lcd.setCursor(60,2);
    if(airPres >= 0){
      lcd.print(airPres);
      lcd.print(" PSI   ");
    }
    else{lcd.print("COM ERR");}
    lcd.setCursor(60,3);
    if(airFlow >= 0){
      lcd.print(airFlow);
      lcd.println(" Nm3/h ");
    }
    else{lcd.print("COM ERR");}
    lcd.setCursor(65,4);
    lcd.print(totalAir);
    lcd.print(" Nm3");
    lcd.setCursor(70,5);
    lcd.print(upPercent);
    lcd.print(" %");
    lcd.setCursor(70,6); 
    lcd.print(standbyRate);
    lcd.setCursor(0,6);    
    if(sdError){ 
      lcd.print("SD card error.");
    }
    else{
      lcd.print("              ");
    }
    lcd.setCursor(0,7);
    if(pumpState){
      lcd.print("PUMP ON ");
    }
    else{
      lcd.print("PUMP OFF");
    }
  }
  else{
    lcd.clear();
    lcd.setCursor(0,2);
    lcd.print("Air Flow: ");
    lcd.print(airFlow);
    lcd.println(" Nm3/h ");
    lcd.setCursor(0,4);
    lcd.print("Pump off threshold: ");
    lcd.setCursor(0,5);
    lcd.print("  ");
    lcd.setCursor(0,5);     
    lcd.print(standbyRate);
    while(changeStandby){
        lcd.setCursor(0,5);
        lcd.print("  ");
        lcd.setCursor(0,5);     
        lcd.print(standbyRate);
        delay(100);     
     }
     byte buf[1] = {byte(standbyRate)};
     FRAMWrite(1, (byte*) buf);
     initDisplay();
    }
  }
  
/*
 * Adjust time of the unit by sending the following over Serial:
 * For 10:14 AM 24 JAN 2018 SUN
 * Send string "Time 1014 2401 2018 1"
 * 
 * Or dumps data from SD with command of "A"
 */
void parseUSB(){
  String Str;
  String workingStr;
  while(SerialUSB.available()){
    char inChar = SerialUSB.read();
    Str += inChar;
    delay(10);
  }

  if(Str.indexOf("Time") >= 0){
   int hrs = Str.substring(5,7).toInt();
   hrs = constrain(hrs,0,23);
   int mins = Str.substring(7,9).toInt();
   mins = constrain(mins,0,59);
   int day = Str.substring(10,12).toInt();
   day = constrain(day,1,31);
   int month = Str.substring(12,14).toInt();
   month = constrain(month,1,12);
   int yr = Str.substring(17,19).toInt();
   yr = constrain(yr,2020,2025);
   int DOW = Str.substring(20,21).toInt();
   DOW = constrain(DOW,1,7);

   RTCind.set(MCP7940_SEC, 0);
   RTCind.set(MCP7940_MIN, mins);
   RTCind.set(MCP7940_HR, hrs);
   RTCind.set(MCP7940_DOW, DOW);
   RTCind.set(MCP7940_DATE, day);
   RTCind.set(MCP7940_MTH, month);
   RTCind.set(MCP7940_YR, yr);
   SerialUSB.println("Time adjusted.");
  }

  if(Str.indexOf("A") >= 0){
    if(SD.exists("data.txt")){
    dataFile = SD.open("data.txt",FILE_READ);
    while(dataFile.peek()>= 0){
      SerialUSB.print(char(dataFile.read()));
    }
    SerialUSB.println();
    dataFile.close();
    }
  }
}

/*
 * Parse RTC
 */
String timeString(){
  int rtc[7];
  String timeString;
  RTCind.get(rtc,true); 

  if (rtc[2]<10) timeString += ("0");
  timeString = (rtc[2]);
  timeString.concat(":");
  if (rtc[1]<10) timeString.concat("0");
  timeString.concat(rtc[1]);
  timeString.concat(":");
  if (rtc[0]<10) timeString += ("0");
  timeString.concat(rtc[0]);
  timeString.concat("\t");
  timeString.concat(rtc[4]);
  timeString.concat("/");
  rtc[5] -= 20;
  timeString.concat(rtc[5]);  
  return(timeString);
}

void totaliser(){
  totalAir += impulseValue;
}

/*
 * Log change of pump state to SD card
 * Change of state from ON -> OFF & OFF -> ON
 * are logged as seperate events written to the same line.
 * Flags SD error if DATA.TXT can't be opened or created.
 */
void logEvent(){
 dataFile = SD.open("data.txt",FILE_WRITE);
    if(SD.exists("data.txt")){
      if(pumpState){
        dataFile.print("ON");
        dataFile.print('\t');
        dataFile.print(timeString());
        dataFile.print('\t');
        dataFile.print(minFlow);
        dataFile.print('\t');
      }
      else{
        dataFile.print("OFF");
        dataFile.print('\t');
        dataFile.print(timeString());
        dataFile.print('\t');
        dataFile.print(maxFlow);
        dataFile.print('\t');
        dataFile.print(upPercent);
        dataFile.print('\t');
        dataFile.print('T');
        dataFile.print('\t');
        dataFile.println(totalAir);
      }
      sdError = 0;
    }
    else{
      sdError = 1; 
    }
  dataFile.close();
}

/*
 *Non changing elements of home screen
 */
void initDisplay(){
  lcd.clear();
  lcd.home();
  lcd.print("CSGME Datalogger v3.0");
  lcd.setCursor(0,2);
  lcd.print("Air Pres: ");
  lcd.setCursor(0,3);
  lcd.print("Air Flow: ");
  lcd.setCursor(0,4);
  lcd.print("Air total: ");
  lcd.setCursor(0,5);
  lcd.print("Duty cycle: ");
}

/*
 * Panel button interrupt functions
 */
void enter(){
  lastAction = millis();
  digitalWrite(backLight,HIGH);
  changeStandby = !changeStandby;
}

void up(){
  lastAction = millis();
  digitalWrite(backLight,HIGH);
  if(changeStandby){
    standbyRate += 5;
  }
  standbyRate = constrain(standbyRate,standbyMin,standbyMax);
}

void down(){
  lastAction = millis();
  digitalWrite(backLight,HIGH);
  if(changeStandby){
    standbyRate -= 5;
    constrain(standbyRate,standbyMin,standbyMax);
  }
  standbyRate = constrain(standbyRate,standbyMin,standbyMax);  
}